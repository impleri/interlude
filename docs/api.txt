Introduction to Interlude
=========================

The Interlude system is similar to other frameworks, mixing ideas found in Joomla, CakePHP, and Ruby on Rails. Its goal is to make a stable framework which is highly modular, configurable, and consistent. To achieve this aim, development utilised a variation of the common MVC pattern which further refines models (the M) to create a basic reusable API (a library) separate from the needs which normally create the model. In separating a simple API library from the standard MVC pattern, Interlude takes reusable code to a new level as development is done with the expectation that another developer may use some aspects of a model in a completely different way.

Like other frameworks, there is a static factory class (ilFactory) which organises and provides core objects.

Here's a quick rundown of each core object and what to expect to find in them:

1. $config: this class is the one that works with all config values.  Any and all variable
settings should be called and accessed through this one class.

$db: this class is the abstraction layer for the database.  All regular database procedures
should run through this.  Every SQL action is required to have a unique name for hook actions
(see next item).

$hooks: this class handles calls to _modify_ an existing function (such as adding a field to a
memberlist display)

$plugins: this class handles calls to _add_ a function (such as adding the above memberlist)

$template: this class is for outputing information to any display.  This includes all HTML,
CSS, and Javascripts as well as handling all language and image variables.

The main difference between hooks and plugins is that plugins have hooks (and even additional
plugins!) within them while hooks do not.  In many ways, the core scripts are primarily hooks
and plugin points.  With everything done this way, the system is completely modular.